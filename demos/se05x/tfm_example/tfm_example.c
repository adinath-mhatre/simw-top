/* Copyright 2020 NXP
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <string.h>

#include "ex_sss_boot.h"
#include "psa/crypto.h"
#include "psa/crypto_se_driver.h"
#include "psa/crypto_types.h"
#include "psa/crypto_values.h"
#include "psa_alt.h"
#include "psa_alt_flash.h"

#ifdef AX_EMBEDDED
#define HAVE_KSDK
#include "ex_sss_main_inc_ksdk.h"
#endif

#include <nxEnsure.h>
#include <nxLog_App.h>

int main(int argc, const char *argv[])
{
    psa_status_t status         = PSA_SUCCESS;
    psa_key_location_t location = PSA_ALT_SE05X_LOCATION;
    psa_key_lifetime_t lifetime = PSA_ALT_SE05X_LIFETIME + PSA_KEY_PERSISTENCE_DEFAULT;
    psa_drv_se_t driver;
    // uint32_t id = 0x20181001;
    psa_key_id_t key_id       = 0x10181001;
    const psa_algorithm_t alg = PSA_ALG_RSA_PKCS1V15_SIGN(PSA_ALG_ANY_HASH);
    //PSA_ALG_RSA_PKCS1V15_CRYPT;
    size_t key_bits  = 1024;
    uint8_t hash[32] = {1};
    size_t hashLen   = sizeof(hash);
    /* clang-format off */
    uint8_t key[] = {0x30, 0x82, 0x02, 0x77, 0x02, 0x01, 0x00, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86,
        0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x02, 0x61, 0x30, 0x82, 0x02,
        0x5D, 0x02, 0x01, 0x00, 0x02, 0x81, 0x81, 0x00, 0xEF, 0x35, 0x43, 0x8C, 0x78, 0xD9,
        0xF8, 0x9C, 0xA5, 0x18, 0x6E, 0x04, 0x71, 0xFF, 0x3F, 0x84, 0xB3, 0xF3, 0x0F, 0xAF,
        0xD9, 0x9B, 0x68, 0x5C, 0x67, 0xB2, 0xDF, 0xDB, 0x8B, 0x43, 0x87, 0xDD, 0x6A, 0x39,
        0x18, 0xFF, 0x45, 0xBD, 0x5C, 0xC0, 0x96, 0x5E, 0x59, 0xBA, 0x27, 0x58, 0x6E, 0xBF,
        0x56, 0x76, 0x22, 0x06, 0x94, 0x5E, 0x36, 0xCB, 0x93, 0x92, 0x2F, 0x83, 0xF7, 0x3C,
        0x7F, 0x08, 0x68, 0x4E, 0xEB, 0xEE, 0x6F, 0x34, 0x12, 0x5A, 0x52, 0xBF, 0xC7, 0x87,
        0xBA, 0x4C, 0x3C, 0x06, 0x8F, 0x1A, 0x36, 0x83, 0xBB, 0x9C, 0x0A, 0x82, 0x1A, 0x50,
        0x06, 0x48, 0xED, 0x97, 0xD5, 0x0B, 0xC5, 0xA9, 0xD9, 0x24, 0x1C, 0xF9, 0x72, 0xB2,
        0x22, 0xB3, 0x32, 0x2D, 0xB3, 0x91, 0x25, 0x16, 0x76, 0xBF, 0x5D, 0xBC, 0x79, 0x14,
        0x56, 0xA5, 0x23, 0x55, 0xF1, 0xA9, 0xB6, 0xE6, 0xED, 0xB9, 0x02, 0x03, 0x01, 0x00,
        0x01, 0x02, 0x81, 0x80, 0x08, 0x0E, 0x34, 0x23, 0x23, 0xE2, 0xBB, 0x43, 0x93, 0x2F,
        0xBA, 0x6C, 0xBD, 0xE6, 0x09, 0x9E, 0x8F, 0x6C, 0xCD, 0x07, 0x6F, 0xFD, 0x92, 0xCB,
        0x21, 0xD6, 0xDD, 0x41, 0x08, 0x74, 0x92, 0xBB, 0xBB, 0x1B, 0x07, 0x23, 0x79, 0x96,
        0xC1, 0xEB, 0xDE, 0x64, 0x79, 0x03, 0x12, 0xD6, 0x20, 0x8C, 0xA2, 0xFD, 0xC1, 0x71,
        0x95, 0x47, 0x82, 0xF2, 0xE2, 0x1A, 0x57, 0x2D, 0x4B, 0x83, 0x27, 0x07, 0xF1, 0xC8,
        0x84, 0x19, 0x61, 0xF1, 0xED, 0x0F, 0x80, 0x1F, 0x91, 0xC5, 0xCF, 0xC5, 0x24, 0xC3,
        0x94, 0xA9, 0x8F, 0x3F, 0xBD, 0x7B, 0x51, 0xAC, 0x05, 0x4D, 0x2B, 0x5C, 0xD1, 0xDD,
        0x08, 0xB0, 0x14, 0x3B, 0x9D, 0xA4, 0x6E, 0x12, 0xCB, 0x5A, 0x37, 0x7B, 0xC9, 0x54,
        0xEB, 0x1F, 0x1C, 0x99, 0x33, 0x92, 0x39, 0x3E, 0xD4, 0x4B, 0xE7, 0x21, 0x83, 0xF8,
        0x37, 0x8B, 0x93, 0x83, 0x70, 0x9D, 0x02, 0x41, 0x00, 0xF8, 0x06, 0x65, 0x67, 0x29,
        0x96, 0xDC, 0xED, 0xDD, 0x14, 0x06, 0x6E, 0x5F, 0x75, 0x88, 0xB4, 0x9F, 0x77, 0xF2,
        0xFA, 0x90, 0x1E, 0x19, 0x58, 0xD6, 0xC8, 0x77, 0x7D, 0x09, 0xE6, 0x97, 0x8D, 0x52,
        0x29, 0xE8, 0x09, 0xD9, 0x5B, 0x43, 0x98, 0xC8, 0xB0, 0x4E, 0xE2, 0x0A, 0x0C, 0x15,
        0x6B, 0x36, 0xD8, 0x35, 0xDE, 0xAF, 0x9C, 0x99, 0x76, 0x35, 0xB2, 0xBC, 0x50, 0x74,
        0x1C, 0x3A, 0xCB, 0x02, 0x41, 0x00, 0xF6, 0xE6, 0x4A, 0xAF, 0xDD, 0x6A, 0x49, 0x53,
        0x44, 0x7B, 0x2A, 0x25, 0x5A, 0xF5, 0xB9, 0x9D, 0xA1, 0x8D, 0xA0, 0x87, 0x58, 0x5F,
        0xFF, 0x63, 0x9C, 0xB5, 0x11, 0x0F, 0x41, 0x8C, 0x85, 0xA1, 0x24, 0x8A, 0xF9, 0xCC,
        0x00, 0x32, 0xF4, 0xA2, 0xF0, 0xB0, 0x16, 0xD4, 0xD4, 0xC8, 0x41, 0x29, 0x8C, 0x4B,
        0x47, 0xC2, 0x3B, 0xC0, 0xE1, 0xCA, 0x00, 0x57, 0xFB, 0xF4, 0x92, 0x21, 0x55, 0x0B,
        0x02, 0x41, 0x00, 0xB9, 0x3C, 0x7D, 0xAB, 0x48, 0x82, 0x65, 0xCA, 0x38, 0x9C, 0xE6,
        0x18, 0xB4, 0xAE, 0xA1, 0x44, 0xD4, 0xFC, 0xCE, 0xB9, 0x97, 0xBD, 0x03, 0x0D, 0x38,
        0x8C, 0x4B, 0xC1, 0x55, 0x0D, 0xA5, 0x0E, 0x64, 0xD8, 0xEB, 0x75, 0xBF, 0xA1, 0xCB,
        0xA0, 0x65, 0xF2, 0x57, 0x57, 0xB6, 0x4D, 0x44, 0x09, 0xE8, 0xD2, 0x1D, 0x99, 0x8C,
        0xEA, 0x96, 0x2A, 0x94, 0xFC, 0x42, 0x6C, 0x8B, 0xEB, 0x31, 0x75, 0x02, 0x41, 0x00,
        0xC3, 0x4A, 0x78, 0xFD, 0x0E, 0x47, 0xC9, 0xE4, 0x01, 0x20, 0xE2, 0xBF, 0x55, 0x69,
        0x53, 0xFE, 0x69, 0x10, 0xDB, 0x4E, 0xF3, 0x0A, 0x4B, 0xBA, 0x00, 0xF3, 0xFF, 0xA0,
        0x6F, 0x9A, 0xB5, 0x00, 0x37, 0x25, 0x6E, 0x5C, 0x7C, 0x33, 0xD1, 0xE9, 0x28, 0x34,
        0x40, 0x7A, 0xEC, 0x2B, 0xD1, 0xCF, 0x09, 0x57, 0x6A, 0x55, 0x2A, 0x6A, 0x70, 0xAE,
        0x15, 0x03, 0x83, 0x19, 0x7A, 0x94, 0xBE, 0xED, 0x02, 0x40, 0x5F, 0x1C, 0x2F, 0x7C,
        0x32, 0x76, 0xB3, 0xE5, 0x04, 0xE7, 0xD0, 0x92, 0x2E, 0x07, 0x5E, 0xE4, 0x02, 0xE9,
        0x23, 0xA4, 0x8E, 0xF8, 0xF8, 0x9D, 0xE2, 0x51, 0xC9, 0x38, 0xF2, 0x74, 0x70, 0x6A,
        0x32, 0xF6, 0x8D, 0x24, 0x29, 0x16, 0x79, 0x39, 0xA2, 0x93, 0xBB, 0xAB, 0xFD, 0xD5,
        0x8E, 0x2C, 0x7C, 0x0B, 0x34, 0x4E, 0x5C, 0x81, 0x80, 0x70, 0x0F, 0x5D, 0x3C, 0x12,
        0x3E, 0x07, 0x07, 0x5E};
    /* clang-format on */
    size_t key_len = sizeof(key);

#ifdef AX_EMBEDDED
    ex_sss_main_ksdk_bm();
#endif // AX_EMBEDDED

    psa_flash_ks_init(false);

    /* Key management driver APIs for PSA */
    psa_drv_se_key_management_t key_mgmt_drv;
    psa_drv_se_asymmetric_t asymm_drv;
    memset(&key_mgmt_drv, 0, sizeof(psa_drv_se_key_management_t));
    memset(&asymm_drv, 0, sizeof(psa_drv_se_asymmetric_t));
    key_mgmt_drv.p_generate             = &psa_alt_generate_key;
    key_mgmt_drv.p_allocate             = &psa_alt_allocate_key;
    key_mgmt_drv.p_export               = &psa_alt_export_key;
    key_mgmt_drv.p_destroy              = &psa_alt_destroy_key;
    key_mgmt_drv.p_import               = &psa_alt_import_key;
    key_mgmt_drv.p_validate_slot_number = &psa_alt_validate_slot_number;
    asymm_drv.p_sign                    = &psa_alt_asymmetric_sign_digest;
    asymm_drv.p_verify                  = &psa_alt_asymmetric_verify_digest;
    asymm_drv.p_encrypt                 = &psa_alt_asymmetric_encrypt;
    asymm_drv.p_decrypt                 = &psa_alt_asymmetric_decrypt;

    memset(&driver, 0, sizeof(driver));
    driver.hal_version = PSA_DRV_SE_HAL_VERSION;

    /* Assign function pointers to SE driver
     * SE Driver has components for different operations:
     *      key_management driver,
     *      cipher driver,
     *      mac driver,
     *      asymmetric driver, etc.
     */

    driver.key_management = &key_mgmt_drv;
    driver.asymmetric     = &asymm_drv;
    driver.p_init         = &psa_alt_driver_init;

    /* First register SE Driver so that it is initialized in psa_crypto_init before performing any operation
     * Maximum of 4 drivers can be registered
     */
    status = psa_register_se_driver(location, &driver);
    ENSURE_OR_GO_EXIT(status == PSA_SUCCESS);
    status = psa_crypto_init();
    ENSURE_OR_GO_EXIT(status == PSA_SUCCESS);

    psa_key_handle_t key_handle = 0;

    /* attributes will contain all details about type of operation to be performed, driver (lifetime) to be used, algorithm, flags, etc */
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    psa_set_key_usage_flags(&attributes,
        PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT | PSA_KEY_USAGE_EXPORT | PSA_KEY_USAGE_SIGN_HASH |
            PSA_KEY_USAGE_VERIFY_HASH);
    psa_set_key_algorithm(&attributes, alg);
    psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_KEY_PAIR);
    psa_set_key_bits(&attributes, key_bits);
    psa_set_key_lifetime(&attributes, lifetime);
    psa_set_key_id(&attributes, key_id);

    status = psa_import_key(&attributes, key, key_len, &key_handle);

    // status = psa_generate_key(&attributes, &key_handle);
    ENSURE_OR_GO_EXIT(status == PSA_SUCCESS);

    status = psa_open_key(key_id, &key_handle);
    ENSURE_OR_GO_EXIT(status == PSA_SUCCESS);

    uint8_t data[256]  = {0};
    size_t data_length = 0;

    status = psa_export_key(key_handle, data, sizeof(data), &data_length);
    ENSURE_OR_GO_EXIT(status == PSA_SUCCESS);
    /*
    Sign verify example:

    */

    uint8_t signature[256] = {0};
    size_t sigLen          = sizeof(signature);

    status = psa_sign_hash(
        key_handle, PSA_ALG_RSA_PKCS1V15_SIGN(PSA_ALG_SHA_256), hash, hashLen, signature, sizeof(signature), &sigLen);
    LOG_X32_I(status);
    LOG_AU8_I(signature, sigLen);
    status = psa_verify_hash(key_handle, PSA_ALG_RSA_PKCS1V15_SIGN(PSA_ALG_SHA_256), hash, hashLen, signature, sigLen);
    LOG_X32_I(status);

    /*
    Encrypt Decrypt example

    uint8_t output[256] = {0};
    size_t outputLen = sizeof(output);
    status = psa_asymmetric_encrypt(key_handle,
        alg,
        hash,
        hashLen,
        NULL,
        0,
        output,
        sizeof(output),
        &outputLen);
    LOG_X32_I(status);
    LOG_AU8_I(output, outputLen);
    //status = psa_asymmetric_decrypt(key_handle, alg, hash, hashLen, NULL, 0, output, sizeof(output), outputLen);
    //LOG_X32_I(status);

    //ENSURE_OR_GO_EXIT(status == PSA_SUCCESS);

    // LOG_AU8_I(data, data_length);
    */
    status = psa_destroy_key(key_handle);
    ENSURE_OR_GO_EXIT(status == PSA_SUCCESS);

    LOG_I("Key erased");

    ENSURE_OR_GO_EXIT(status == PSA_SUCCESS);

exit:

    if (status == PSA_SUCCESS) {
        LOG_I("Example Success");
        return 0;
    }
    else {
        LOG_E("Example failed");
        return 1;
    }
}
